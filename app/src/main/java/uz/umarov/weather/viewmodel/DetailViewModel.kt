package uz.umarov.weather.viewmodelimport android.util.Logimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport kotlinx.coroutines.launchimport uz.umarov.weather.APPIDimport uz.umarov.weather.BASE_URLimport uz.umarov.weather.CardDetailimport uz.umarov.weather.KELVIN_TO_CELSIUSimport uz.umarov.weather.LATITUDEimport uz.umarov.weather.LONGITUDEimport uz.umarov.weather.api.DailyForecastApiimport uz.umarov.weather.api.WeatherApiimport uz.umarov.weather.model.Weatherimport java.text.DateFormatimport java.util.Calendarimport java.util.Dateimport kotlin.math.roundToIntclass DetailViewModel : ViewModel() {    private val _response = MutableLiveData<String>()    val response: LiveData<String>        get() = _response    private var _weather = MutableLiveData<Weather>()    val weather: LiveData<Weather>        get() = _weather    private var list: ArrayList<CardDetail> = ArrayList()    private var _listDailyWeather = MutableLiveData<ArrayList<CardDetail>>()        .apply { postValue(ArrayList()) }    val listDailyWeather: LiveData<ArrayList<CardDetail>>        get() = _listDailyWeather    init {        getDailyForecast()        getWeather()        Log.i("Detail VM", "init detail VM")    }    private fun getDailyForecast() {        viewModelScope.launch {            try {                Log.i("Debug", "Long: ${LONGITUDE}, Lat: ${LATITUDE}")                val result = DailyForecastApi.dailyForecastService.getDailyForecast(                    LATITUDE,                    LONGITUDE,                    APPID                )//                _weatherForecast.value = result                for (i: Int in 1 until result.daily.size) {                    val iconUrl = BASE_URL + "/img/w/" + result.daily[i].weather[0].icon + ".png"                    result.daily[i].temp?.max?.minus(KELVIN_TO_CELSIUS)?.roundToInt()                        ?.let { tempMax ->                            result.daily[i].temp?.min?.minus(KELVIN_TO_CELSIUS)?.roundToInt()                                ?.let { tempMin ->                                    CardDetail(tempMax, tempMin, iconUrl, getDateTime(i))                                }                        }?.let { _listDailyWeather.value?.add(it) }                }                _listDailyWeather.value = _listDailyWeather.value                _response.value = "Success!!!"                Log.i("Detail VM", "list size: ${list.size}")                Log.i("Detail VM", "forecastFiveDay size: ${_listDailyWeather.value?.size}")                Log.i("Detail VM", _response.value!!)            } catch (e: Exception) {                _response.value = "Failure: ${e.message}"                Log.i("Detail VM", e.toString())            }        }    }    private fun getWeather() {        viewModelScope.launch {            try {                val result =                    WeatherApi.retrofitService.getCurrentWeatherData(LATITUDE, LONGITUDE, APPID)                _weather.value = result                _response.value = "Success!!!"            } catch (e: Exception) {                _response.value = "Failure: ${e.message}"                Log.i("VM", e.toString())            }        }    }    private fun getDateTime(i: Int): String {        var date = Date()        val calendar = Calendar.getInstance()        calendar.time = date        calendar.add(Calendar.DATE, i)        date = calendar.time        return DateFormat.getDateInstance(            DateFormat.SHORT        )            .format(date).toString()    }}